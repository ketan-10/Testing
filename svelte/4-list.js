// VDOM and non-vDOM

// you have huge list, you just want to update one specific field
// there is no way to update one specific field, with just DOM api like getElementById

//  a = [aklsd, aslkfjalas, owkljew, wklejrl ... ]
// if it was some rendering engine, 
// that would just render each frame and take this list and directly construct the new state and render 
// the problem with browser is, there is no auto bind the DOM (state) with this list variable, 
// // as dom was designed to be static and not change, the dom manipulation part was added later on. 
// // otherwise it would have had some mechanism to bind, or all together re-calculate the state each render. otherthan it just being a string. 
// what if we write the program as we would have for a engine, we assume it would render each frame. and internally we have vDOM which is how state would have actually maintained if browser was created now a days. 
// now as vDOM creation is super fast, as it being an object. for that list, when list change (or for each frame in engine) re-create the vDOM.

// // but as we are dealing with real world here and we stuck with DOM, browser can't render vDOM, we diff vDOM each change and get what change and then update DOM whatever required.
// // for some reason creating whole DOM each frame is expensive, due to some bad design I don't properly understand.

// -- Framework without vDOM.
// - old v4 svelte :- old v4 svelte we define each element as 'u' update, 'd' destroy, 'c' create, 'm' mount,
//   create function just create the DOM with createElement and store it
//   mount actually mounts it to our DOM 
//   u update have a dirty check with variable and if conditions
// -- for list 
// In svelte is react imminently when list change, 
// when something change we invalidate with the id of thing which changed, id is a integer bit representation
// When list changes, we check each element for update by calling ‘update’ for each element passing the invalidate dirty id, 
// lets say it was the list only which was changed, now for each element we check old list value and new and update the dom accordingly 

// — in svelte when list changes, we immediately check i.e go through each element stored in list and compare with old value store. 
// Where ever we are using it, if the value is changed we invoke Dom update for that part

// https://svelte.dev/playground/65b4675deae144a88d4dfeeac2cb7d0d?version=4.0.0#H4sIAAAAAAAAA5VV227jNhD9lanSXTtYX2UHBRRJRZGX7VuB7luUB0oaWUQoUiAp24Ghf1_wolhOvEkLQxY1tzOcORyeAk4aDKLgOzIm4CAkK4NZUFGGKogeT4F-aY3aCILZYPxX2y7UHpk2spwovCYvBNfItQqiIOOxKiRtdZrxjGd6uYSHmvAdgq5RIWgBWnYIQkJFmBOoWhyMGkpaVSiRa8ixJnsqOqlMEIYa9lTRnOHfvBKQON9BxbsmRwkJPBrJyfxlulG7CDK32fk6C2ZObBVhBBNXhUZIhPXE6PoZXHMNP3QNveuvgDcfem8-8d5-6L39xPvuQ-875_3k2lR1vNBUcKC8kNgg1w-i43p6O9TkXOPFYuE-XuvlcSeCo409eQs7KGDv6uVxdZ_xeDmiS1yv038tqWALPyThitqkSmxEvKzXzoiRHFk6UseUt50Gw98kC4oai-dcHLMAcsrLyH5jmZxGDOphmcZLF8jGLOk-tXW8odWYar0Rxm36o0aJcKCMQY5AQJ_Rc2TiAEa_iJeti7KkVe8Ke7pBUtQDRYkyq97VIK7D9MS7ZtGoXR8v6zAd5NtXeWgU21fFJv1O4XIj8bLeeFCD5GHjvNNacBA8KhgtnpPTZWP71IqhwXjpTFPTC1OGYBZoPOogMue0n_1iLjyIphUcuQ6vjodr6tGUGM0IXQiuNBSCCakMvyYSy8kMJkKasWFWL4a1B7PaSURuFjnrrIryku6EWe2pYKgnT_fDVFDIsNBYQuKDP66M8i3hQOkXZnljjCI4DX59FqT_mBoR69_JMwPPbLHN9bkT5VYzoEOHXWmH00AkJfOik2bCJadzfonPsL8wtOxMTpeaIdmcFM87KTpeRjCYBIPRuenTW0jSd5Xw0dIThW-w7kcMGLHIkcFu14Jabb0ezvz5AEQuKKwWobr3p9q8SrofjEuqWkZeIthJWt47mVnONTYtIxrnhWBdw1UEElskevrHDNaVvB3b7kgbwV179LKGHOcHWuo6gu1q5cUe2pPfoxPVYqHnkmgqIlh7_1zIEuVckpJ2KoK71ZdBMSrtnsjpfO67elNV1ZCR3X4lZBO5UWA2MZ2H7XFm_garijKNMoJSinaualKKwzRsj2CeTXsEucvJdDWzv0V4exHc15YwBqvFWr3f3uMFnbLAHNcseLpokMuQC45vMhqJcnH0uUVAuUJtUzPP9n2KQxrx0pHifw6LzcfDYvPpsDAHuzADDBJY3V9IwkHEM_17BEMdwL3MlBEMF0zspv6CNDflzPkOlacVTF34L7BeQ5LACr5-9Yi_JbC6Pd95Y1CL4uW0mnrVFwhtiJHT20REWUKYBQO-a7Gz5OPPc_Nfb-qa8JLhgzno52vaZfot8TTvLzwUFoKXby52n-vY5XJEvrtJRsC9bYpdYmkGkbla7BjxTUoSWMOfMNG0wUnk3mpiMc5D5wrGKNVrGOEIJPyvKGbch-kQwF-4lwR-6n8Cg5V7VCYLAAA=

<script>

	// Change these to true or false to show the different behaviours
	let visibleInfo = false
	let number = [
	{
		msg: "Hello-1",
			msg2: 'Hello more 1'
	}, {
		msg: "Hello-2",
			msg2: 'Hello more 2'
	},
	{
		msg: "Hello-3",
			msg2: 'Hello more 3'
	},
	{
		msg: "Hello-4",
			msg2: 'Hello more 4'
	},
	{
		msg: "Hello-5",
			msg2: 'Hello more 5'
	}]

	function incrementCount() {
		number = [...number, {
			msg: 'one more',
			msg2: 'one more v2'
		}]
	}
</script>

<h1>Svelte 4 Transition demo</h1>

<label>Transition <input type="checkbox" bind:checked={visibleInfo} /></label>

<div>
	{#if visibleInfo}
	<p>There will be a transition below here.</p>
	{/if}

	{#each number as num}
		<h2>{num.msg}</h2>
		<h4>{num.msg2}</h4>
		<h3>Hi {visibleInfo} </h3>
	{/each}

	<button on:click={incrementCount}>click me</button>
</div>


//////////////////
/* App.svelte generated by Svelte v4.0.0 */
import {
	SvelteComponent,
	append,
	attr,
	destroy_each,
	detach,
	element,
	ensure_array_like,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text
} from "svelte/internal";

import "svelte/internal/disclose-version";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (38:1) {#if visibleInfo}
function create_if_block(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "There will be a transition below here.";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(p);
			}
		}
	};
}

// (42:1) {#each number as num}
function create_each_block(ctx) {
	let h2;
	let t0_value = /*num*/ ctx[4].msg + "";
	let t0;
	let t1;
	let h4;
	let t2_value = /*num*/ ctx[4].msg2 + "";
	let t2;
	let t3;
	let h3;
	let t4;
	let t5;

	return {
		c() {
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			h4 = element("h4");
			t2 = text(t2_value);
			t3 = space();
			h3 = element("h3");
			t4 = text("Hi ");
			t5 = text(/*visibleInfo*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t0);
			insert(target, t1, anchor);
			insert(target, h4, anchor);
			append(h4, t2);
			insert(target, t3, anchor);
			insert(target, h3, anchor);
			append(h3, t4);
			append(h3, t5);
		},
		p(ctx, dirty) {
			if (dirty & /*number*/ 2 && t0_value !== (t0_value = /*num*/ ctx[4].msg + "")) set_data(t0, t0_value);
			if (dirty & /*number*/ 2 && t2_value !== (t2_value = /*num*/ ctx[4].msg2 + "")) set_data(t2, t2_value);
			if (dirty & /*visibleInfo*/ 1) set_data(t5, /*visibleInfo*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				detach(h2);
				detach(t1);
				detach(h4);
				detach(t3);
				detach(h3);
			}
		}
	};
}

function create_fragment(ctx) {
	let h1;
	let t1;
	let label;
	let t2;
	let input;
	let t3;
	let div;
	let t4;
	let t5;
	let button;
	let mounted;
	let dispose;
	let if_block = /*visibleInfo*/ ctx[0] && create_if_block(ctx);
	let each_value = ensure_array_like(/*number*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			h1 = element("h1");
			h1.textContent = "Svelte 4 Transition demo";
			t1 = space();
			label = element("label");
			t2 = text("Transition ");
			input = element("input");
			t3 = space();
			div = element("div");
			if (if_block) if_block.c();
			t4 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			button = element("button");
			button.textContent = "click me";
			attr(input, "type", "checkbox");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			insert(target, t1, anchor);
			insert(target, label, anchor);
			append(label, t2);
			append(label, input);
			input.checked = /*visibleInfo*/ ctx[0];
			insert(target, t3, anchor);
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			append(div, t5);
			append(div, button);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[3]),
					listen(button, "click", /*incrementCount*/ ctx[2])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*visibleInfo*/ 1) {
				input.checked = /*visibleInfo*/ ctx[0];
			}

			if (/*visibleInfo*/ ctx[0]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, t4);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*visibleInfo, number*/ 3) {
				each_value = ensure_array_like(/*number*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t5);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(h1);
				detach(t1);
				detach(label);
				detach(t3);
				detach(div);
			}

			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let visibleInfo = false;

	let number = [
		{ msg: "Hello-1", msg2: 'Hello more 1' },
		{ msg: "Hello-2", msg2: 'Hello more 2' },
		{ msg: "Hello-3", msg2: 'Hello more 3' },
		{ msg: "Hello-4", msg2: 'Hello more 4' },
		{ msg: "Hello-5", msg2: 'Hello more 5' }
	];

	function incrementCount() {
		$$invalidate(1, number = [...number, { msg: 'one more', msg2: 'one more v2' }]);
	}

	function input_change_handler() {
		visibleInfo = this.checked;
		$$invalidate(0, visibleInfo);
	}

	return [visibleInfo, number, incrementCount, input_change_handler];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;

